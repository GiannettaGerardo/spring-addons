# How to configure a Spring REST API with an additional security filter-chain for UI resources

The aim here is to enable OAuth2 security for UI resources in addition to REST API ones and enable auto-login when a user browses to a secured page.

Be sure your environment meets [tutorials prerequisits](https://github.com/ch4mpy/spring-addons/blob/master/samples/tutorials/README.md#prerequisites).

This tutorial is using `spring-addons-webmvc-jwt-resource-server` with a custom Authentication implementation but you can apply OAuth2 client configuration here after to any of other tutorials and samples. 

## Start a new project
We'll start a spring-boot 3 project with the help of https://start.spring.io/
Following dependencies will be needed:
- lombok
- spring-boot-starter-oauth2-client
- spring-boot-starter-actuator

Then add this dependencies to spring-addons:
```xml
		<dependency>
			<groupId>com.c4-soft.springaddons</groupId>
			<artifactId>spring-addons-webmvc-jwt-resource-server</artifactId>
			<version>6.0.8</version>
		</dependency>
		<dependency>
			<groupId>org.springdoc</groupId>
			<artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
			<version>2.0.0</version>
		</dependency>
		<dependency>
			<groupId>com.c4-soft.springaddons</groupId>
			<artifactId>spring-addons-webmvc-jwt-test</artifactId>
			<version>6.0.8</version>
			<scope>test</scope>
		</dependency>
```

## Web-security config
`spring-addons-webmvc-jwt-resource-server` auto-configures a default `SecurityFilterChain` which is adapted to resource servers.
We will add another `SecurityFilterChain` which should apply selectively to all UI elements: those required for OAuth2 login generated by spring-boot and Swagger-UI.
```java
@EnableMethodSecurity
public static class SecurityConfig {
    @Order(Ordered.HIGHEST_PRECEDENCE)
    @Bean
    SecurityFilterChain uiFilterChain(HttpSecurity http, ServerProperties serverProperties) throws Exception {
        boolean isSsl = serverProperties.getSsl() != null && serverProperties.getSsl().isEnabled();
    
        // @formatter:off
        http.securityMatcher(new OrRequestMatcher(
                // you might want to add path to your UI elements instead
                new AntPathRequestMatcher("/swagger-ui/**"),
                // those two are required to access Spring generated login page
                // and OAuth2 client callback endpoints
                new AntPathRequestMatcher("/login/**"),
                new AntPathRequestMatcher("/oauth2/**")));
    
        http.oauth2Login()
            // I don't know quite why we are redirected to authorization-server port by default as initial login page is generated on client :/
            .loginPage("%s://localhost:%d/oauth2/authorization/spring-addons-public".formatted(isSsl ? "https" : "http", serverProperties.getPort()))
            // I don't know quite why we are redirected to authorization-server port by default as we initially tried to access a client resource :/
			.defaultSuccessUrl("%s://localhost:%d/swagger-ui/index.html".formatted(isSsl ? "https" : "http", serverProperties.getPort()), true)
            // This is how to map authorities from ID-token claims of our choice (instead of just `scp` claim)
            // Here we make use of the authorities mapper already defined by spring-addons for default filter-chain (the one for resource-server)
            // Refer to your authorization doc if it does not include roles to ID-tokens by default. For Keycloak, "realm roles" & "client roles" mappers must be added in clients -> {your client} -> Client scopes -> {your client}-dedicated -> Add mapper.
            .userInfoEndpoint().userAuthoritiesMapper((authorities) -> authorities.stream()
                .filter(a -> OidcUserAuthority.class.isAssignableFrom(a.getClass()))
                .map(OidcUserAuthority.class::cast)
                .flatMap(oua -> authoritiesConverter.convert(oua.getIdToken().getClaims()).stream()).toList()
            );
    
        http.authorizeHttpRequests()
                .requestMatchers("/login/**").permitAll()
                .requestMatchers("/oauth2/**").permitAll()
                .anyRequest().authenticated();
        // @formatter:on
    
        // If SSL enabled, disable http (https only)
        if (isSsl) {
            http.requiresChannel().anyRequest().requiresSecure();
        } else {
            http.requiresChannel().anyRequest().requiresInsecure();
        }
    
        // compared to API filter-chain:
        // - sessions and CSRF protection are left enabled
        // - unauthorized requests to secured resources will be redirected to login (302 to login is Spring's default response when access is
        // denied)
    
        return http.build();
    }
}
```

## `application.properties`:
```properties
com.c4-soft.springaddons.security.permit-all=/actuator/health/readiness,/actuator/health/liveness,/actuator/health/readiness,/actuator/health/liveness,/v3/api-docs,/v3/api-docs/**,/login/**/oauth2/**

spring.security.oauth2.client.provider.keycloak.issuer-uri=https://localhost:8443/realms/master

spring.security.oauth2.client.registration.spring-addons-public.provider=keycloak
spring.security.oauth2.client.registration.spring-addons-public.client-name=spring-addons-public
spring.security.oauth2.client.registration.spring-addons-public.client-id=spring-addons-public
spring.security.oauth2.client.registration.spring-addons-public.scope=openid,offline_access,profile
spring.security.oauth2.client.registration.spring-addons-public.authorization-grant-type=authorization_code

# use IDE auto-completion or see SpringAddonsSecurityProperties javadoc for complete configuration properties list

management.endpoint.health.probes.enabled=true
management.health.readinessstate.enabled=true
management.health.livenessstate.enabled=true
management.endpoints.web.exposure.include=*
spring.lifecycle.timeout-per-shutdown-phase=30s
```

That's it:
- REST end-points are secured as `resource-server` (require an access-token in authorization header), without session and 401 being returned if authorization is missing or invalid when trying to access protected resources
- UI resources are secured as `client` with sessions and user is redirected to login page when trying to access a protected page
